<!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-->
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>Apache Flink 1.1-SNAPSHOT Documentation: Flink DataStream API 编程指南</title>
    <link rel="shortcut icon" href="/page/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/page/favicon.ico" type="image/x-icon">

    <!-- Bootstrap -->
    <link href="//cdn.bootcss.com/bootstrap/3.3.4/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/page/css/flink.css">
    <link rel="stylesheet" href="/page/css/syntax.css">
    <link rel="stylesheet" href="/page/css/codetabs.css">
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    
    





    <!-- Top navbar. -->
    <nav class="navbar navbar-default navbar-fixed-top">
      <div class="container">
        <!-- The logo. -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <div class="navbar-logo">
            <a href="http://flink.apache.org"><img alt="Apache Flink" src="/page/img/navbar-brand-logo.jpg"></a>
          </div>
        </div><!-- /.navbar-header -->

        <!-- The navigation links. -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
          <ul class="nav navbar-nav">
            <li class="hidden-sm "><a href="/">中文文档 1.1</a></li>

            <!-- Quickstart -->
            <li class="dropdown">
              <a href="/quickstart" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">快速起步<span class="caret"></span></a>
              <ul class="dropdown-menu" role="menu">
                
                
                <li class=""><a href="/quickstart/setup_quickstart.html">安装</a></li>
                
                <li class=""><a href="/quickstart/run_example_quickstart.html">Run Example</a></li>
                
                <li class=""><a href="/quickstart/java_api_quickstart.html">Java API</a></li>
                
                <li class=""><a href="/quickstart/scala_api_quickstart.html">Scala API</a></li>
                
              </ul>
            </li>

            <!-- Setup -->
            <li class="dropdown">
              <a href="/setup" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">安装 <span class="caret"></span></a>
              <ul class="dropdown-menu" role="menu">
                
                
                <li class=""><a href="/setup/building.html">Build Flink</a></li>
                
                <li class=""><a href="/setup/config.html">Configuration</a></li>
                

                <li class="divider"></li>
                <li role="presentation" class="dropdown-header"><strong>部署</strong></li>
                
                
                <li class=""><a href="/setup/local_setup.html">本地</a></li>
                
                <li class=""><a href="/setup/cluster_setup.html">集群 (Standalone)</a></li>
                
                <li class=""><a href="/setup/yarn_setup.html">YARN</a></li>
                
                <li class=""><a href="/setup/gce_setup.html">Google Compute Engine</a></li>
                
                <li class=""><a href="/setup/jobmanager_high_availability.html">High Availability</a></li>
                
              </ul>
            </li>

            <!-- Programming Guides -->
            <li class="dropdown active">
              <a href="/apis" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">编程指南 <span class="caret"></span></a>
              <ul class="dropdown-menu" role="menu">
                
                
                <li class=""><a href="/apis/common/"><strong>Basic Concepts</strong></a></li>
                
                <li class="active"><a href="/apis/streaming/"><strong>Streaming 指南</strong> (DataStream API)</a></li>
                
                <li class=""><a href="/apis/batch/"><strong>Batch Guide</strong> (DataSet API)</a></li>
                
                <li class=""><a href="/apis/connectors.html">Connectors</a></li>
                
                <li class=""><a href="/apis/best_practices.html">Best Practices</a></li>
                
                <li class=""><a href="/apis/cli.html">Command-Line Interface</a></li>
                
                <li class=""><a href="/apis/local_execution.html">Local Execution</a></li>
                
                <li class=""><a href="/apis/cluster_execution.html">Cluster Execution</a></li>
                
                <li class=""><a href="/apis/scala_shell.html">Scala Shell</a></li>
                
                <li class=""><a href="/apis/java8.html">Java 8</a></li>
                
              </ul>
            </li>

            <!-- Libraries -->
            <li class="dropdown">
              <a href="/libs" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">库 <span class="caret"></span></a>
                <ul class="dropdown-menu" role="menu">
                  
                  
                  <li class=""><a href="/apis/batch/libs/gelly.html">Graphs: Gelly</a></li>
                  
                  <li class=""><a href="/apis/streaming/libs/cep.html">CEP</a></li>
                  
                  <li class=""><a href="/apis/batch/libs/ml/">Machine Learning</a></li>
                  
                  <li class=""><a href="/apis/batch/libs/table.html">Relational: Table</a></li>
                  
              </ul>
            </li>

            <!-- Internals -->
            <li class="dropdown">
              <a href="/internals" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">内部 <span class="caret"></span></a>
              <ul class="dropdown-menu" role="menu">
                <li role="presentation" class="dropdown-header"><strong>Contribute</strong></li>
                <li><a href="http://flink.apache.org/how-to-contribute.html"><small><span class="glyphicon glyphicon-new-window"></span></small> How to Contribute</a></li>
                <li><a href="http://flink.apache.org/contribute-code.html#coding-guidelines"><small><span class="glyphicon glyphicon-new-window"></span></small> Coding Guidelines</a></li>
                
                
                <li class=""><a href="/internals/ide_setup.html">IDE Setup</a></li>
                
                <li class=""><a href="/internals/logging.html">Logging</a></li>
                
                <li class=""><a href="/internals/general_arch.html">Architecture and Process Model</a></li>
                
                <li class=""><a href="/internals/stream_checkpointing.html">Fault Tolerance for Data Streaming</a></li>
                
                <li class=""><a href="/internals/types_serialization.html">Type Extraction and Serialization</a></li>
                
                <li class=""><a href="/internals/monitoring_rest_api.html">Monitoring REST API</a></li>
                
                <li class=""><a href="/internals/job_scheduling.html">Jobs and Scheduling</a></li>
                
                <li class=""><a href="/internals/add_operator.html">How-To: Add an Operator</a></li>
                
              </ul>
            </li>

            <li class="hidden-sm "><a href="/about/">关于本站</a></li>

          </ul>
          <form class="navbar-form navbar-right hidden-sm hidden-md" role="search" action="/search-results.html">
            <div class="form-group">
              <input type="text" class="form-control" size="16px" name="q" placeholder="Search all pages">
            </div>
            <button type="submit" class="btn btn-default">Search</button>
          </form>
        </div><!-- /.navbar-collapse -->
      </div><!-- /.container -->
    </nav>


    

    <!-- Main content. -->
    <div class="container">
      
      
<div class="row">


  <!-- Sub Navigation -->
  <div class="col-sm-3">
    <ul id="sub-nav">
      
      
      
        
        <li><a href="/apis/streaming/" class="active">DataStream API</a>
          
        </li>
      
        
        <li><a href="/apis/streaming/windows.html" class="">Windows</a>
          
          <ul>
            
              <li><a href="/apis/streaming/time.html" class="">Working with Time</a></li>
            
          </ul>
          
        </li>
      
        
        <li><a href="/apis/streaming/fault_tolerance.html" class="">Fault Tolerance</a>
          
          <ul>
            
              <li><a href="/apis/streaming/state.html" class="">Working with State</a></li>
            
              <li><a href="/apis/streaming/state_backends.html" class="">State Backends</a></li>
            
          </ul>
          
        </li>
      
        
        <li><a href="/apis/streaming/savepoints.html" class="">Savepoints</a>
          
        </li>
      
        
        <li><a href="/apis/streaming/connectors/" class="">Connectors</a>
          
          <ul>
            
              <li><a href="/apis/streaming/connectors/kafka.html" class="">Kafka</a></li>
            
              <li><a href="/apis/streaming/connectors/elasticsearch.html" class="">Elasticsearch</a></li>
            
              <li><a href="/apis/streaming/connectors/hdfs.html" class="">HDFS</a></li>
            
              <li><a href="/apis/streaming/connectors/rabbitmq.html" class="">RabbitMQ</a></li>
            
              <li><a href="/apis/streaming/connectors/twitter.html" class="">Twitter</a></li>
            
          </ul>
          
        </li>
      
        
        <li><a href="/apis/streaming/libs/" class="">Libraries</a>
          
          <ul>
            
              <li><a href="/apis/streaming/libs/cep.html" class="">Event Processing (CEP)</a></li>
            
          </ul>
          
        </li>
      
        
        <li><a href="/apis/streaming/storm_compatibility.html" class="">Storm Compatibility</a>
          
        </li>
      
    </ul>
  </div>
  <!-- Main -->
  <div class="col-sm-9">
    <!-- Top anchor -->
    <a href="#top"></a>

    <!-- Artifact name change warning. Remove for the 1.0 release. -->
    
    <div class="panel panel-default">
      <div class="panel-body"><strong>重要</strong>: 依赖于Scala的maven artifacts现在会添加一个Scala主版本的后缀，例如 "2.10" 或 "2.11". 请查阅<a href="https://cwiki.apache.org/confluence/display/FLINK/Maven+artifact+names+suffixed+with+Scala+version">迁移指南</a>.</div>
    </div>
    

    <!-- Breadcrumbs above the main heading -->
    <ol class="breadcrumb">
      
      
      <li><a href="/apis/streaming/">Streaming 指南</a></li>
      
      
      
      
      
      
      
      
      
      
      
      
      
      

      
      <li class="active">DataStream API</li>
    </ol>

    <div class="text">
      <!-- Main heading -->
      <h1>Flink DataStream API 编程指南</h1>

      <!-- Content -->
      

<p>Flink 中的 DataStream API 是对数据流进行转换操作（例如，过滤、更新状态、定义窗口、聚合）常用的方式。数据流可以从各种源（例如，消息队列、socket流、文件）创建而来。结果通过 sinks 操作返回，例如可能是将数据写入到文件，或者到标准输出（如命令行窗口）。Flink 程序可以运行在多样的环境下，standalone集群，或者嵌入其他程序中。执行过程可以发生在本地，也可以是由许多机器构成的集群上。</p>

<p>Please see <a href="/apis/common/index.html">basic concepts</a> for an introduction
to the basic concepts of the Flink API.</p>

<p>In order to create your own Flink DataStream program, we encourage you to start with
<a href="/apis/common/index.html#anatomy-of-a-flink-program">anatomy of a Flink Program</a>
and gradually add your own
<a href="#datastream-transformations">transformations</a>. The remaining sections act as references for additional
operations and advanced features.</p>

<p>请先阅读<a href="/apis/common/index.html">基本概念</a>了解下 Flink API 的基本概念。</p>

<p>为了创建你的第一个 Flink DataStream 程序，我们鼓励你从 <a href="/apis/common/index.html#anatomy-of-a-flink-program">剖析 Flink 程序</a> 开始，然后逐步地增加你的 <a href="#datastream-transformations">转换操作</a>。而剩余的章节主要作为额外操作(operations)和高级特性的一个参考。</p>

<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">样例程序</a></li>
  <li><a href="#datastream-transformations" id="markdown-toc-datastream-transformations">DataStream 转换（Transformations）</a>    <ul>
      <li><a href="#section-1" id="markdown-toc-section-1">物理分区</a></li>
      <li><a href="#section-2" id="markdown-toc-section-2">任务链和资源组</a></li>
    </ul>
  </li>
  <li><a href="#section-3" id="markdown-toc-section-3">数据源</a></li>
  <li><a href="#sinks" id="markdown-toc-sinks">数据下沉（Sinks）</a></li>
  <li><a href="#iterations" id="markdown-toc-iterations">迭代（Iterations）</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">执行参数</a>    <ul>
      <li><a href="#section-5" id="markdown-toc-section-5">容错</a></li>
      <li><a href="#section-6" id="markdown-toc-section-6">延迟控制</a></li>
    </ul>
  </li>
  <li><a href="#section-7" id="markdown-toc-section-7">调试</a>    <ul>
      <li><a href="#section-8" id="markdown-toc-section-8">本地执行环境</a></li>
      <li><a href="#section-9" id="markdown-toc-section-9">集合数据源</a></li>
      <li><a href="#iterator-data-sink" id="markdown-toc-iterator-data-sink">数据接收迭代器（Iterator Data Sink）</a></li>
    </ul>
  </li>
</ul>

<h2 id="section">样例程序</h2>

<p>下面这段程序是一个完整的，可运行的，基于流和窗口的 word count 应用样例。从一个网络socket中以5秒的窗口统计单词数量。你可以复制 &amp; 粘贴这段代码，然后在本地跑一跑。</p>

<div class="codetabs">
  <div data-lang="java">

    <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">org.apache.flink.api.common.functions.FlatMapFunction</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.flink.api.java.tuple.Tuple2</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.flink.streaming.api.datastream.DataStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.flink.streaming.api.environment.StreamExecutionEnvironment</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.flink.streaming.api.windowing.time.Time</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.flink.util.Collector</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WindowWordCount</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

        <span class="n">StreamExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">StreamExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>

        <span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">dataStream</span> <span class="o">=</span> <span class="n">env</span>
                <span class="o">.</span><span class="na">socketTextStream</span><span class="o">(</span><span class="s">&quot;localhost&quot;</span><span class="o">,</span> <span class="mi">9999</span><span class="o">)</span>
                <span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="nf">Splitter</span><span class="o">())</span>
                <span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
                <span class="o">.</span><span class="na">timeWindow</span><span class="o">(</span><span class="n">Time</span><span class="o">.</span><span class="na">seconds</span><span class="o">(</span><span class="mi">5</span><span class="o">))</span>
                <span class="o">.</span><span class="na">sum</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

        <span class="n">dataStream</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>

        <span class="n">env</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="s">&quot;Window WordCount&quot;</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Splitter</span> <span class="kd">implements</span> <span class="n">FlatMapFunction</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">flatMap</span><span class="o">(</span><span class="n">String</span> <span class="n">sentence</span><span class="o">,</span> <span class="n">Collector</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="nl">word:</span> <span class="n">sentence</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">out</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="k">new</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;(</span><span class="n">word</span><span class="o">,</span> <span class="mi">1</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure>

  </div>

  <div data-lang="scala">

    <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.flink.streaming.api.scala._</span>
<span class="k">import</span> <span class="nn">org.apache.flink.streaming.api.windowing.time.Time</span>

<span class="k">object</span> <span class="nc">WindowWordCount</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="o">{</span>

    <span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">StreamExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>
    <span class="k">val</span> <span class="n">text</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">socketTextStream</span><span class="o">(</span><span class="s">&quot;localhost&quot;</span><span class="o">,</span> <span class="mi">9999</span><span class="o">)</span>

    <span class="k">val</span> <span class="n">counts</span> <span class="k">=</span> <span class="n">text</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span> <span class="k">_</span><span class="o">.</span><span class="n">toLowerCase</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot;\\W+&quot;</span><span class="o">)</span> <span class="n">filter</span> <span class="o">{</span> <span class="k">_</span><span class="o">.</span><span class="n">nonEmpty</span> <span class="o">}</span> <span class="o">}</span>
      <span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">}</span>
      <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
      <span class="o">.</span><span class="n">timeWindow</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">5</span><span class="o">))</span>
      <span class="o">.</span><span class="n">sum</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

    <span class="n">counts</span><span class="o">.</span><span class="n">print</span>

    <span class="n">env</span><span class="o">.</span><span class="n">execute</span><span class="o">(</span><span class="s">&quot;Window Stream WordCount&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

  </div>

</div>

<p>要在本地运行本样例程序，需要先从终端启动 netcat 作为输入流：</p>

<div class="highlight"><pre><code class="language-bash">nc -lk 9999</code></pre></div>

<p>然后在终端中敲一些单词进去，这些会作为 word count 程序的输入。如果你想要看到统计值大于1的，在5秒内不断地敲入一样的单词（如果你手速没这么快，可以将5秒的窗口调大☺）。</p>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h2 id="datastream-transformations">DataStream 转换（Transformations）</h2>

<p>数据的转换操作可以讲一个或多个 DataStream 转换成一个新的 DataStream。程序可以合并多个转换操作为复杂的拓扑结构。</p>

<p>本节对所有可用的转换操作做了个简单描述。</p>

<div class="codetabs">
  <div data-lang="java">

    <table class="table table-bordered">
  <thead>
    <tr>
      <th class="text-left" style="width: 25%">转换</th>
      <th class="text-center">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
          <td><strong>Map</strong><br />DataStream &rarr; DataStream</td>
          <td>
            <p>输入一个元素，生成另一个元素，元素类型不变。一个将输入流中的值双倍返回的 map 函数：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">dataStream</span> <span class="o">=</span> <span class="c1">//...</span>
<span class="n">dataStream</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="k">new</span> <span class="n">MapFunction</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">map</span><span class="o">(</span><span class="n">Integer</span> <span class="n">value</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">});</span></code></pre></figure>

          </td>
        </tr>

        <tr>
          <td><strong>FlatMap</strong><br />DataStream &rarr; DataStream</td>
          <td>
            <p>输入一个元素，生成零个、一个或者多个元素。一个将句子切分成多个单词的 flatmap 函数：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">dataStream</span><span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="n">FlatMapFunction</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">flatMap</span><span class="o">(</span><span class="n">String</span> <span class="n">value</span><span class="o">,</span> <span class="n">Collector</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="n">String</span> <span class="nl">word:</span> <span class="n">value</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">)){</span>
            <span class="n">out</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">});</span></code></pre></figure>

          </td>
        </tr>
        <tr>
          <td><strong>Filter</strong><br />DataStream &rarr; DataStream</td>
          <td>
            <p>对每个元素执行一个布尔函数，只保留返回 true 的元素。一个过滤掉零值的 filter 函数：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">dataStream</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="k">new</span> <span class="n">FilterFunction</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">filter</span><span class="o">(</span><span class="n">Integer</span> <span class="n">value</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">value</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">});</span></code></pre></figure>

          </td>
        </tr>
        <tr>
          <td><strong>KeyBy</strong><br />DataStream &rarr; KeyedStream</td>
          <td>
            <p>将流逻辑分区成不相交的分区，每个分区包含相同 key 的元素。内部是用 hash 分区来实现的。查阅 <a href="#specifying-keys">keys</a> 了解如何指定 keys。这个转换返回了一个 KeyedDataStream。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">dataStream</span><span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="s">&quot;someKey&quot;</span><span class="o">)</span> <span class="c1">// Key by field &quot;someKey&quot;</span>
<span class="n">dataStream</span><span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="c1">// Key by the first element of a Tuple</span></code></pre></figure>

          </td>
        </tr>
        <tr>
          <td><strong>Reduce</strong><br />KeyedStream &rarr; DataStream</td>
          <td>
            <p>在一个 KeyedStream 上“滚动” reduce 。合并当前元素与上一个被 reduce 的值，然后输出新的值。注意三者的类型是一致的。
              <br /><br />
              一个构造局部求和流的 reduce 函数：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">keyedStream</span><span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="k">new</span> <span class="n">ReduceFunction</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">Integer</span> <span class="n">value1</span><span class="o">,</span> <span class="n">Integer</span> <span class="n">value2</span><span class="o">)</span>
    <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">value1</span> <span class="o">+</span> <span class="n">value2</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">});</span></code></pre></figure>

            
          </td>
        </tr>
        <tr>
          <td><strong>Fold</strong><br />KeyedStream &rarr; DataStream</td>
          <td>
          <p>在一个 KeyedStream 上基于一个初始值“滚动”折叠。合并当前元素和上一个被折叠的值，然后输出新值。注意 Fold 的输入值与返回值类型可以不一致。
          <br />
          <br />
          <p>需要将序列 (1,2,3,4,5) 转换成 "start-1", "start-1-2", "start-1-2-3", ... 的一个 fold 函数长这个样子：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataStream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span>
  <span class="n">keyedStream</span><span class="o">.</span><span class="na">fold</span><span class="o">(</span><span class="s">&quot;start&quot;</span><span class="o">,</span> <span class="k">new</span> <span class="n">FoldFunction</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">fold</span><span class="o">(</span><span class="n">String</span> <span class="n">current</span><span class="o">,</span> <span class="n">Integer</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">current</span> <span class="o">+</span> <span class="s">&quot;-&quot;</span> <span class="o">+</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">});</span></code></pre></figure>

          </p>
          </td>
        </tr>
        <tr>
          <td><strong>Aggregations</strong><br />KeyedStream &rarr; DataStream</td>
          <td>
            <p>在一个 KeyedStream 上滚动聚合。min 与 minBy 的区别是 min 返回了最小值，而 minBy 返回了在这个字段上是最小值的所有元素（max 和 maxBy 也是同样的）。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">keyedStream</span><span class="o">.</span><span class="na">sum</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="na">sum</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">);</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">);</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">);</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="na">minBy</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="na">minBy</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">);</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="na">maxBy</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="na">maxBy</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">);</span></code></pre></figure>

          </td>
        </tr>
        <tr>
          <td><strong>Window</strong><br />KeyedStream &rarr; WindowedStream</td>
          <td>
            <p>窗口可以被定义在已经被分区的 KeyedStreams 上。窗口会对数据的每一个 key 根据一些特征（例如，在最近 5 秒中内到达的数据）进行分组。查阅<a href="windows.html">窗口</a>了解关于窗口的完整描述。

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">dataStream</span><span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">window</span><span class="o">(</span><span class="n">TumblingEventTimeWindows</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Time</span><span class="o">.</span><span class="na">seconds</span><span class="o">(</span><span class="mi">5</span><span class="o">)));</span> <span class="c1">// Last 5 seconds of data</span></code></pre></figure>

        </p>
          </td>
        </tr>
        <tr>
          <td><strong>WindowAll</strong><br />DataStream &rarr; AllWindowedStream</td>
          <td>
              <p>窗口可以被定义在 DataStream 上。窗口会对所有数据流事件根据一些特征（例如，在最近 5 秒中内到达的数据）进行分组。查阅<a href="windows.html">窗口</a>了解关于窗口的完整描述。</p>
              <p><strong>警告:</strong> 这在许多案例中这是一种<strong>非并行</strong>的转换。所有的记录都会被聚集到一个执行 WindowAll 操作的 task 中，这是非常影响性能的。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">dataStream</span><span class="o">.</span><span class="na">windowAll</span><span class="o">(</span><span class="n">TumblingEventTimeWindows</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Time</span><span class="o">.</span><span class="na">seconds</span><span class="o">(</span><span class="mi">5</span><span class="o">)));</span> <span class="c1">// Last 5 seconds of data</span></code></pre></figure>

          </td>
        </tr>
        <tr>
          <td><strong>Window Apply</strong><br />WindowedStream &rarr; DataStream<br />AllWindowedStream &rarr; DataStream</td>
          <td>
            <p>应用一个一般的函数到窗口上，窗口中的数据会作为一个整体被计算。下面的函数手工地计算了一个窗口中的元素总和。
            </p>
            <p><strong>注意:</strong> 如果你正在使用一个 WindowAll 的转换，你需要用 AllWindowFunction 来替换。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">windowedStream</span><span class="o">.</span><span class="na">apply</span> <span class="o">(</span><span class="k">new</span> <span class="n">WindowFunction</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">Integer</span><span class="o">&gt;,</span> <span class="n">Integer</span><span class="o">,</span> <span class="n">Tuple</span><span class="o">,</span> <span class="n">Window</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">apply</span> <span class="o">(</span><span class="n">Tuple</span> <span class="n">tuple</span><span class="o">,</span>
            <span class="n">Window</span> <span class="n">window</span><span class="o">,</span>
            <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">values</span><span class="o">,</span>
            <span class="n">Collector</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">value</span> <span class="nl">t:</span> <span class="n">values</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">t</span><span class="o">.</span><span class="na">f1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">out</span><span class="o">.</span><span class="na">collect</span> <span class="o">(</span><span class="k">new</span> <span class="nf">Integer</span><span class="o">(</span><span class="n">sum</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">});</span>

<span class="c1">// applying an AllWindowFunction on non-keyed window stream</span>
<span class="n">allWindowedStream</span><span class="o">.</span><span class="na">apply</span> <span class="o">(</span><span class="k">new</span> <span class="n">AllWindowFunction</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">Integer</span><span class="o">&gt;,</span> <span class="n">Integer</span><span class="o">,</span> <span class="n">Window</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">apply</span> <span class="o">(</span><span class="n">Window</span> <span class="n">window</span><span class="o">,</span>
            <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">values</span><span class="o">,</span>
            <span class="n">Collector</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">value</span> <span class="nl">t:</span> <span class="n">values</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">t</span><span class="o">.</span><span class="na">f1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">out</span><span class="o">.</span><span class="na">collect</span> <span class="o">(</span><span class="k">new</span> <span class="nf">Integer</span><span class="o">(</span><span class="n">sum</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">});</span></code></pre></figure>

          </td>
        </tr>
        <tr>
          <td><strong>Window Reduce</strong><br />WindowedStream &rarr; DataStream</td>
          <td>
            <p>应用一个 reduce 函数到窗口上，返回 reduce 后的值。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">windowedStream</span><span class="o">.</span><span class="na">reduce</span> <span class="o">(</span><span class="k">new</span> <span class="n">ReduceFunction</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">value1</span><span class="o">,</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">value2</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">Integer</span><span class="o">&gt;(</span><span class="n">value1</span><span class="o">.</span><span class="na">f0</span><span class="o">,</span> <span class="n">value1</span><span class="o">.</span><span class="na">f1</span> <span class="o">+</span> <span class="n">value2</span><span class="o">.</span><span class="na">f1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">};</span></code></pre></figure>

          </td>
        </tr>
        <tr>
          <td><strong>Window Fold</strong><br />WindowedStream &rarr; DataStream</td>
          <td>
            <p>应用一个 fold 函数到窗口上，然后返回折叠后的值。
            在窗口上将序列 (1,2,3,4,5) 转换成 "start-1", "start-1-2", "start-1-2-3", ... 的一个 fold 函数长这个样子：
            </p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">windowedStream</span><span class="o">.</span><span class="na">fold</span><span class="o">(</span><span class="s">&quot;start-&quot;</span><span class="o">,</span> <span class="k">new</span> <span class="n">FoldFunction</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">fold</span><span class="o">(</span><span class="n">String</span> <span class="n">current</span><span class="o">,</span> <span class="n">Integer</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">current</span> <span class="o">+</span> <span class="s">&quot;-&quot;</span> <span class="o">+</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">};</span></code></pre></figure>

          </td>
        </tr>
        <tr>
          <td><strong>Aggregations on windows</strong><br />WindowedStream &rarr; DataStream</td>
          <td>
            <p>聚合一个窗口中的内容。min 与 minBy 的区别是 min 返回了最小值，而 minBy 返回了在这个字段上是最小值的所有元素（max 和 maxBy 也是同样的）。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">windowedStream</span><span class="o">.</span><span class="na">sum</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="na">sum</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">);</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">);</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">);</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="na">minBy</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="na">minBy</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">);</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="na">maxBy</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="na">maxBy</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">);</span></code></pre></figure>

          </td>
        </tr>
        <tr>
          <td><strong>Union</strong><br />DataStream* &rarr; DataStream</td>
          <td>
            <p>Union 两个或多个数据流，生成一个新的包含了来自所有流的所有数据的数据流。注意：如果你将一个数据流与其自身进行了合并，在结果流中对于每个元素你都会拿到两份。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">dataStream</span><span class="o">.</span><span class="na">union</span><span class="o">(</span><span class="n">otherStream1</span><span class="o">,</span> <span class="n">otherStream2</span><span class="o">,</span> <span class="o">...);</span></code></pre></figure>

          </td>
        </tr>
        <tr>
          <td><strong>Window Join</strong><br />DataStream,DataStream &rarr; DataStream</td>
          <td>
            <p>在一个给定的 key 和窗口上 join 两个数据流。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">dataStream</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="n">otherStream</span><span class="o">)</span>
    <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">equalTo</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="n">TumblingEventTimeWindows</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Time</span><span class="o">.</span><span class="na">seconds</span><span class="o">(</span><span class="mi">3</span><span class="o">)))</span>
    <span class="o">.</span><span class="na">apply</span> <span class="o">(</span><span class="k">new</span> <span class="nf">JoinFunction</span> <span class="o">()</span> <span class="o">{...});</span></code></pre></figure>

          </td>
        </tr>
        <tr>
          <td><strong>Window CoGroup</strong><br />DataStream,DataStream &rarr; DataStream</td>
          <td>
            <p>在一个给定的 key 和窗口上 co-group 两个数据流。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">dataStream</span><span class="o">.</span><span class="na">coGroup</span><span class="o">(</span><span class="n">otherStream</span><span class="o">)</span>
    <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">equalTo</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="n">TumblingEventTimeWindows</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Time</span><span class="o">.</span><span class="na">seconds</span><span class="o">(</span><span class="mi">3</span><span class="o">)))</span>
    <span class="o">.</span><span class="na">apply</span> <span class="o">(</span><span class="k">new</span> <span class="nf">CoGroupFunction</span> <span class="o">()</span> <span class="o">{...});</span></code></pre></figure>

          </td>
        </tr>
        <tr>
          <td><strong>Connect</strong><br />DataStream,DataStream &rarr; ConnectedStreams</td>
          <td>
            <p>“连接”两个数据流并保持原先的类型。Connect 可以让两条流之间共享状态。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">someStream</span> <span class="o">=</span> <span class="c1">//...</span>
<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">otherStream</span> <span class="o">=</span> <span class="c1">//...</span>

<span class="n">ConnectedStreams</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">connectedStreams</span> <span class="o">=</span> <span class="n">someStream</span><span class="o">.</span><span class="na">connect</span><span class="o">(</span><span class="n">otherStream</span><span class="o">);</span></code></pre></figure>

          </td>
        </tr>
        <tr>
          <td><strong>CoMap, CoFlatMap</strong><br />ConnectedStreams &rarr; DataStream</td>
          <td>
            <p>在一个 ConnectedStreams 上做类似 map 和 flatMap 的操作。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">connectedStreams</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="k">new</span> <span class="n">CoMapFunction</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">,</span> <span class="n">Boolean</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Boolean</span> <span class="nf">map1</span><span class="o">(</span><span class="n">Integer</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Boolean</span> <span class="nf">map2</span><span class="o">(</span><span class="n">String</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">});</span>
<span class="n">connectedStreams</span><span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="n">CoFlatMapFunction</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>

   <span class="nd">@Override</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">flatMap1</span><span class="o">(</span><span class="n">Integer</span> <span class="n">value</span><span class="o">,</span> <span class="n">Collector</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">out</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
   <span class="o">}</span>

   <span class="nd">@Override</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">flatMap2</span><span class="o">(</span><span class="n">String</span> <span class="n">value</span><span class="o">,</span> <span class="n">Collector</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="nl">word:</span> <span class="n">value</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">))</span> <span class="o">{</span>
         <span class="n">out</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>
       <span class="o">}</span>
   <span class="o">}</span>
<span class="o">});</span></code></pre></figure>

          </td>
        </tr>
        <tr>
          <td><strong>Split</strong><br />DataStream &rarr; SplitStream</td>
          <td>
            <p>
            根据具体的标准切分数据流成两个或多个流。

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">SplitStream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">split</span> <span class="o">=</span> <span class="n">someDataStream</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="k">new</span> <span class="n">OutputSelector</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">select</span><span class="o">(</span><span class="n">Integer</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">output</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;even&quot;</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="n">output</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;odd&quot;</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">output</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">});</span></code></pre></figure>

            </p>
          </td>
        </tr>
        <tr>
          <td><strong>Select</strong><br />SplitStream &rarr; DataStream</td>
          <td>
            <p>
                从一个 SplitStream 中选出一个或多个流。

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">SplitStream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">split</span><span class="o">;</span>
<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">even</span> <span class="o">=</span> <span class="n">split</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="s">&quot;even&quot;</span><span class="o">);</span>
<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">odd</span> <span class="o">=</span> <span class="n">split</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="s">&quot;odd&quot;</span><span class="o">);</span>
<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">all</span> <span class="o">=</span> <span class="n">split</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="s">&quot;even&quot;</span><span class="o">,</span><span class="s">&quot;odd&quot;</span><span class="o">);</span></code></pre></figure>

            </p>
          </td>
        </tr>
        <tr>
          <td><strong>Iterate</strong><br />DataStream &rarr; IterativeStream &rarr; DataStream</td>
          <td>
            <p>
                在流(flow)中创建一个带反馈的循环，通过重定向一个 operator 的输出到之前的 operator。这对于定义一些需要不断更新模型的算法是非常有帮助的。下面这段代码对一个流不断地应用迭代体。大于 0 的元素会被发送到反馈通道，剩余的元素会继续发往下游。查阅 <a href="#iterations">迭代</a> 了解完整的描述。


<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">IterativeStream</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">iteration</span> <span class="o">=</span> <span class="n">initialStream</span><span class="o">.</span><span class="na">iterate</span><span class="o">();</span>
<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">iterationBody</span> <span class="o">=</span> <span class="n">iteration</span><span class="o">.</span><span class="na">map</span> <span class="o">(</span><span class="cm">/*do something*/</span><span class="o">);</span>
<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">feedback</span> <span class="o">=</span> <span class="n">iterationBody</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="k">new</span> <span class="n">FilterFunction</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;(){</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">filter</span><span class="o">(</span><span class="n">Integer</span> <span class="n">value</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">});</span>
<span class="n">iteration</span><span class="o">.</span><span class="na">closeWith</span><span class="o">(</span><span class="n">feedback</span><span class="o">);</span>
<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">output</span> <span class="o">=</span> <span class="n">iterationBody</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="k">new</span> <span class="n">FilterFunction</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;(){</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">filter</span><span class="o">(</span><span class="n">Integer</span> <span class="n">value</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">});</span></code></pre></figure>

            </p>
          </td>
        </tr>
        <tr>
          <td><strong>提取时间戳</strong><br />DataStream &rarr; DataStream</td>
          <td>
            <p>
                为了能够工作于使用 event time 语义的窗口，需要从记录中提取时间戳。查阅 <a href="/apis/streaming/time.html">working with time</a> 了解更多。 
                

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">stream</span><span class="o">.</span><span class="na">assignTimestamps</span> <span class="o">(</span><span class="k">new</span> <span class="nf">TimeStampExtractor</span><span class="o">()</span> <span class="o">{...});</span></code></pre></figure>

            </p>
          </td>
        </tr>
  </tbody>
</table>

  </div>

  <div data-lang="scala">

    <table class="table table-bordered">
  <thead>
    <tr>
      <th class="text-left" style="width: 25%">转换</th>
      <th class="text-center">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
          <td><strong>Map</strong><br />DataStream &rarr; DataStream</td>
          <td>
            <p>输入一个元素，生成另一个元素，元素类型不变。一个将输入流中的值双倍返回的 map 函数：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">}</span></code></pre></figure>

          </td>
        </tr>

        <tr>
          <td><strong>FlatMap</strong><br />DataStream &rarr; DataStream</td>
          <td>
            <p>输入一个元素，生成零个、一个或者多个元素。一个将句子切分成多个单词的 flatmap 函数：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">str</span> <span class="k">=&gt;</span> <span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">)</span> <span class="o">}</span></code></pre></figure>

          </td>
        </tr>
        <tr>
          <td><strong>Filter</strong><br />DataStream &rarr; DataStream</td>
          <td>
            <p>对每个元素执行一个布尔函数，只保留返回 true 的元素。一个过滤掉零值的 filter 函数：
            </p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">filter</span> <span class="o">{</span> <span class="k">_</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">}</span></code></pre></figure>

          </td>
        </tr>
        <tr>
          <td><strong>KeyBy</strong><br />DataStream &rarr; KeyedStream</td>
          <td>
            <p>将流逻辑分区成不相交的分区，每个分区包含相同 key 的元素。内部是用 hash 分区来实现的。查阅 <a href="#specifying-keys">keys</a> 了解如何指定 keys。这个转换返回了一个 KeyedDataStream。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="s">&quot;someKey&quot;</span><span class="o">)</span> <span class="c1">// Key by field &quot;someKey&quot;</span>
<span class="n">dataStream</span><span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="c1">// Key by the first element of a Tuple</span></code></pre></figure>

          </td>
        </tr>
        <tr>
          <td><strong>Reduce</strong><br />KeyedStream &rarr; DataStream</td>
          <td>
            <p>在一个 KeyedStream 上“滚动” reduce 。合并当前元素与上一个被 reduce 的值，然后输出新的值。注意三者的类型是一致的。 
                    <br />
              <br />
            一个构造局部求和流的 reduce 函数：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">keyedStream</span><span class="o">.</span><span class="n">reduce</span> <span class="o">{</span> <span class="k">_</span> <span class="o">+</span> <span class="k">_</span> <span class="o">}</span></code></pre></figure>

            
          </td>
        </tr>
        <tr>
          <td><strong>Fold</strong><br />KeyedStream &rarr; DataStream</td>
          <td>
          <p>在一个 KeyedStream 上基于一个初始值“滚动”折叠。合并当前元素和上一个被折叠的值，然后输出新值。注意 Fold 的输入值与返回值类型可以不一致。 
          <br />
          <br />
          <p>需要将序列 (1,2,3,4,5) 转换成 "start-1", "start-1-2", "start-1-2-3", ... 的一个 fold 函数长这个样子：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">result</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">keyedStream</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="s">&quot;start&quot;</span><span class="o">,</span> <span class="o">(</span><span class="n">str</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span> <span class="n">str</span> <span class="o">+</span> <span class="s">&quot;-&quot;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">})</span></code></pre></figure>

          </p>
          </td>
        </tr>
        <tr>
          <td><strong>Aggregations</strong><br />KeyedStream &rarr; DataStream</td>
          <td>
            <p>在一个 KeyedStream 上滚动聚合。min 与 minBy 的区别是 min 返回了最小值，而 minBy 返回了在这个字段上是最小值的所有元素（max 和 maxBy 也是同样的）。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">keyedStream</span><span class="o">.</span><span class="n">sum</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="n">sum</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">)</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="n">min</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="n">min</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">)</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="n">max</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="n">max</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">)</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="n">minBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="n">minBy</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">)</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="n">maxBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="n">maxBy</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">)</span></code></pre></figure>

          </td>
        </tr>
        <tr>
          <td><strong>Window</strong><br />KeyedStream &rarr; WindowedStream</td>
          <td>
            <p>窗口可以被定义在已经被分区的 KeyedStreams 上。窗口会对数据的每一个 key 根据一些特征（例如，在最近 5 秒中内到达的数据）进行分组。查阅<a href="windows.html">窗口</a>了解关于窗口的完整描述。
            

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">window</span><span class="o">(</span><span class="nc">TumblingEventTimeWindows</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">5</span><span class="o">)))</span> <span class="c1">// Last 5 seconds of data</span></code></pre></figure>

        </p>
          </td>
        </tr>
        <tr>
          <td><strong>WindowAll</strong><br />DataStream &rarr; AllWindowedStream</td>
          <td>
              <p>窗口可以被定义在 DataStream 上。窗口会对所有数据流事件根据一些特征（例如，在最近 5 秒中内到达的数据）进行分组。查阅<a href="windows.html">窗口</a>了解关于窗口的完整描述。
              </p>
              <p><strong>警告:</strong> 这在许多案例中这是一种<strong>非并行</strong>的转换。所有的记录都会被聚集到一个执行 WindowAll 操作的 task 中，这是非常影响性能的。
              </p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">windowAll</span><span class="o">(</span><span class="nc">TumblingEventTimeWindows</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">5</span><span class="o">)))</span> <span class="c1">// Last 5 seconds of data</span></code></pre></figure>

          </td>
        </tr>
        <tr>
          <td><strong>Window Apply</strong><br />WindowedStream &rarr; DataStream<br />AllWindowedStream &rarr; DataStream</td>
          <td>
            <p>应用一个一般的函数到窗口上，窗口中的数据会作为一个整体被计算。下面的函数手工地计算了一个窗口中的元素总和。</p>
            <p><strong>注意:</strong> 如果你正在使用一个 WindowAll 的转换，你需要用 AllWindowFunction 来替换。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">windowedStream</span><span class="o">.</span><span class="n">apply</span> <span class="o">{</span> <span class="nc">WindowFunction</span> <span class="o">}</span>

<span class="c1">// applying an AllWindowFunction on non-keyed window stream</span>
<span class="n">allWindowedStream</span><span class="o">.</span><span class="n">apply</span> <span class="o">{</span> <span class="nc">AllWindowFunction</span> <span class="o">}</span></code></pre></figure>

          </td>
        </tr>
        <tr>
          <td><strong>Window Reduce</strong><br />WindowedStream &rarr; DataStream</td>
          <td>
            <p>应用一个 reduce 函数到窗口上，返回 reduce 后的值。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">windowedStream</span><span class="o">.</span><span class="n">reduce</span> <span class="o">{</span> <span class="k">_</span> <span class="o">+</span> <span class="k">_</span> <span class="o">}</span></code></pre></figure>

          </td>
        </tr>
        <tr>
          <td><strong>Window Fold</strong><br />WindowedStream &rarr; DataStream</td>
          <td>
            <p>应用一个 fold 函数到窗口上，然后返回折叠后的值。 在窗口上将序列 (1,2,3,4,5) 转换成 "start-1", "start-1-2", "start-1-2-3", ... 的一个 fold 函数长这个样子：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">result</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">windowedStream</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="s">&quot;start&quot;</span><span class="o">,</span> <span class="o">(</span><span class="n">str</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span> <span class="n">str</span> <span class="o">+</span> <span class="s">&quot;-&quot;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">})</span></code></pre></figure>

          </td>
  </tr>
        <tr>
          <td><strong>Aggregations on windows</strong><br />WindowedStream &rarr; DataStream</td>
          <td>
            <p>聚合一个窗口中的内容。min 与 minBy 的区别是 min 返回了最小值，而 minBy 返回了在这个字段上是最小值的所有元素（max 和 maxBy 也是同样的）。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">windowedStream</span><span class="o">.</span><span class="n">sum</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="n">sum</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">)</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="n">min</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="n">min</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">)</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="n">max</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="n">max</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">)</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="n">minBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="n">minBy</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">)</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="n">maxBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="n">maxBy</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">)</span></code></pre></figure>

          </td>
        </tr>
        <tr>
          <td><strong>Union</strong><br />DataStream* &rarr; DataStream</td>
          <td>
            <p>Union 两个或多个数据流，生成一个新的包含了来自所有流的所有数据的数据流。注意：如果你将一个数据流与其自身进行了合并，在结果流中对于每个元素你都会拿到两份。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">union</span><span class="o">(</span><span class="n">otherStream1</span><span class="o">,</span> <span class="n">otherStream2</span><span class="o">,</span> <span class="o">...)</span></code></pre></figure>

          </td>
        </tr>
        <tr>
          <td><strong>Window Join</strong><br />DataStream,DataStream &rarr; DataStream</td>
          <td>
            <p>在一个给定的 key 和窗口上 join 两个数据流。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">join</span><span class="o">(</span><span class="n">otherStream</span><span class="o">)</span>
    <span class="o">.</span><span class="n">where</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">equalTo</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">.</span><span class="n">window</span><span class="o">(</span><span class="nc">TumblingEventTimeWindows</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">3</span><span class="o">)))</span>
    <span class="o">.</span><span class="n">apply</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span></code></pre></figure>

          </td>
        </tr>
        <tr>
          <td><strong>Window CoGroup</strong><br />DataStream,DataStream &rarr; DataStream</td>
          <td>
            <p>在一个给定的 key 和窗口上 co-group 两个数据流。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">coGroup</span><span class="o">(</span><span class="n">otherStream</span><span class="o">)</span>
    <span class="o">.</span><span class="n">where</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">equalTo</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">.</span><span class="n">window</span><span class="o">(</span><span class="nc">TumblingEventTimeWindows</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">3</span><span class="o">)))</span>
    <span class="o">.</span><span class="n">apply</span> <span class="o">{}</span></code></pre></figure>

          </td>
        </tr>
        <tr>
          <td><strong>Connect</strong><br />DataStream,DataStream &rarr; ConnectedStreams</td>
          <td>
            <p>“连接”两个数据流并保持原先的类型。Connect 可以让两条流之间共享状态。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">someStream</span> <span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
<span class="n">otherStream</span> <span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="k">val</span> <span class="n">connectedStreams</span> <span class="k">=</span> <span class="n">someStream</span><span class="o">.</span><span class="n">connect</span><span class="o">(</span><span class="n">otherStream</span><span class="o">)</span></code></pre></figure>

          </td>
        </tr>
        <tr>
          <td><strong>CoMap, CoFlatMap</strong><br />ConnectedStreams &rarr; DataStream</td>
          <td>
            <p>在一个 ConnectedStreams 上做类似 map 和 flatMap 的操作。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">connectedStreams</span><span class="o">.</span><span class="n">map</span><span class="o">(</span>
    <span class="o">(</span><span class="k">_</span> <span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">true</span><span class="o">,</span>
    <span class="o">(</span><span class="k">_</span> <span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">)</span>
<span class="n">connectedStreams</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span>
    <span class="o">(</span><span class="k">_</span> <span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">true</span><span class="o">,</span>
    <span class="o">(</span><span class="k">_</span> <span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">)</span></code></pre></figure>

          </td>
        </tr>
        <tr>
          <td><strong>Split</strong><br />DataStream &rarr; SplitStream</td>
          <td>
            <p>
                根据具体的标准切分数据流成两个或多个流。


<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">split</span> <span class="k">=</span> <span class="n">someDataStream</span><span class="o">.</span><span class="n">split</span><span class="o">(</span>
  <span class="o">(</span><span class="n">num</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">2</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="mi">0</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;even&quot;</span><span class="o">)</span>
      <span class="k">case</span> <span class="mi">1</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;odd&quot;</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">)</span></code></pre></figure>

            </p>
          </td>
        </tr>
        <tr>
          <td><strong>Select</strong><br />SplitStream &rarr; DataStream</td>
          <td>
            <p>
                从一个 SplitStream 中选出一个或多个流。


<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">even</span> <span class="k">=</span> <span class="n">split</span> <span class="n">select</span> <span class="s">&quot;even&quot;</span>
<span class="k">val</span> <span class="n">odd</span> <span class="k">=</span> <span class="n">split</span> <span class="n">select</span> <span class="s">&quot;odd&quot;</span>
<span class="k">val</span> <span class="n">all</span> <span class="k">=</span> <span class="n">split</span><span class="o">.</span><span class="n">select</span><span class="o">(</span><span class="s">&quot;even&quot;</span><span class="o">,</span><span class="s">&quot;odd&quot;</span><span class="o">)</span></code></pre></figure>

            </p>
          </td>
        </tr>
        <tr>
          <td><strong>Iterate</strong><br />DataStream &rarr; IterativeStream  &rarr; DataStream</td>
          <td>
            <p>
              在流(flow)中创建一个带反馈的循环，通过重定向一个 operator 的输出到之前的 operator。这对于定义一些需要不断更新模型的算法是非常有帮助的。下面这段代码对一个流不断地应用迭代体。大于 0 的元素会被发送到反馈通道，剩余的元素会继续发往下游。查阅 <a href="#iterations">迭代</a> 了解完整的描述。


<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">initialStream</span><span class="o">.</span><span class="na">iterate</span> <span class="o">{</span>
  <span class="n">iteration</span> <span class="o">=&gt;</span> <span class="o">{</span>
    <span class="n">val</span> <span class="n">iterationBody</span> <span class="o">=</span> <span class="n">iteration</span><span class="o">.</span><span class="na">map</span> <span class="o">{</span><span class="cm">/*do something*/</span><span class="o">}</span>
    <span class="o">(</span><span class="n">iterationBody</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">),</span> <span class="n">iterationBody</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">_</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

            </p>
          </td>
        </tr>
        <tr>
          <td><strong>提取时间戳</strong><br />DataStream &rarr; DataStream</td>
          <td>
            <p>
                为了能够工作于使用 event time 语义的窗口，需要从记录中提取时间戳。查阅 <a href="/apis/streaming/time.html">working with time</a> 了解更多。

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">stream</span><span class="o">.</span><span class="n">assignTimestamps</span> <span class="o">{</span> <span class="n">timestampExtractor</span> <span class="o">}</span></code></pre></figure>

            </p>
          </td>
        </tr>
  </tbody>
</table>

  </div>
</div>

<p>下面的转换只适用于基于 Tuple 类型的数据流：</p>

<div class="codetabs">
  <div data-lang="java">

    <table class="table table-bordered">
  <thead>
    <tr>
      <th class="text-left" style="width: 20%">转换</th>
      <th class="text-center">描述</th>
    </tr>
  </thead>
  <tbody>
   <tr>
      <td><strong>投影</strong><br />DataStream &rarr; DataStream</td>
      <td>
        <p>从元组中选择了一部分字段子集。

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">in</span> <span class="o">=</span> <span class="c1">// [...]</span>
<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">out</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">project</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span></code></pre></figure>

        </p>
      </td>
    </tr>
  </tbody>
</table>

  </div>

  <div data-lang="scala">

    <table class="table table-bordered">
  <thead>
    <tr>
      <th class="text-left" style="width: 20%">转换</th>
      <th class="text-center">描述</th>
    </tr>
  </thead>
  <tbody>
   <tr>
      <td><strong>投影</strong><br />DataStream &rarr; DataStream</td>
      <td>
        <p>从元组中选择了一部分字段子集。

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">in</span> <span class="k">:</span> <span class="kt">DataStream</span><span class="o">[(</span><span class="kt">Int</span>,<span class="kt">Double</span>,<span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]</span>
<span class="k">val</span> <span class="n">out</span> <span class="k">=</span> <span class="n">in</span><span class="o">.</span><span class="n">project</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">0</span><span class="o">)</span></code></pre></figure>

        </p>
      </td>
    </tr>
  </tbody>
</table>

  </div>
</div>

<h3 id="section-1">物理分区</h3>

<p>在流转换后，Flink 在精确控制流分区上也提供了底层的控制（如果需要），通过下面的函数可以实现。</p>

<div class="codetabs">
  <div data-lang="java">

    <table class="table table-bordered">
  <thead>
    <tr>
      <th class="text-left" style="width: 20%">转换</th>
      <th class="text-center">描述</th>
    </tr>
  </thead>
  <tbody>
   <tr>
      <td><strong>自定义分区</strong><br />DataStream &rarr; DataStream</td>
      <td>
        <p>
            使用一个用户自定义的 Partitioner 对每一个元素选择目标 task。
          

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">dataStream</span><span class="o">.</span><span class="na">partitionCustom</span><span class="o">(</span><span class="n">partitioner</span><span class="o">,</span> <span class="s">&quot;someKey&quot;</span><span class="o">);</span>
<span class="n">dataStream</span><span class="o">.</span><span class="na">partitionCustom</span><span class="o">(</span><span class="n">partitioner</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span></code></pre></figure>

        </p>
      </td>
    </tr>
   <tr>
     <td><strong>随机分区</strong><br />DataStream &rarr; DataStream</td>
     <td>
       <p>
            以均匀分布的形式将元素随机地进行分区。
          

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">dataStream</span><span class="o">.</span><span class="na">shuffle</span><span class="o">();</span></code></pre></figure>

       </p>
     </td>
   </tr>
   <tr>
      <td><strong>Rebalancing (Round-robin partitioning)</strong><br />DataStream &rarr; DataStream</td>
      <td>
        <p>
            基于 round-robin 对元素进行分区，使得每个分区负责均衡。对于存在数据倾斜的性能优化是很有用的。
            

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">dataStream</span><span class="o">.</span><span class="na">rebalance</span><span class="o">();</span></code></pre></figure>

        </p>
      </td>
    </tr>
    <tr>
      <td><strong>Rescaling</strong><br />DataStream &rarr; DataStream</td>
      <td>
        <p>
            以 round-robin 的形式将元素分区到下游操作的子集中。如果你想要将数据从一个源的每个并行实例中散发到一些 mappers 的子集中，用来分散负载，但是又不想要完全的 rebalance 介入（引入 `rebalance()`），这会非常有用。根据一些如TaskManager 的 slots 个数的配置，这将会只需要本地数据传输，而不是通过网络。
        </p>
        <p>
            上游操作所发送的元素被分区到下游操作的哪些子集，依赖于上游和下游操作的并发度。例如，如果上游操作的并发为 2 ，而下游操作的并发为 4 ，那么一个上游操作会分发元素给两个下游操作，同时另一个上游操作会分发给另两个下游操作。相反的，如果下游操作的并发为 2 ，而下游操作的并发为4，那么两个上游操作会分发数据给一个下游操作，同时另两个上游操作会分发数据给另一个下游操作。
        </p>
        <p>
            在上下游的并发度不是呈倍数关系的情况下，下游操作会有数量不同的来自上游操作的输入。
        </p>
        
            下图是对上述例子的一个可视化：
        

        <div style="text-align: center">
            <img src="/apis/streaming/fig/rescale.svg" alt="Checkpoint barriers in data streams" />
            </div>


        <p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">dataStream</span><span class="o">.</span><span class="na">rescale</span><span class="o">();</span></code></pre></figure>


        </p>
      </td>
    </tr>
   <tr>
      <td><strong>广播</strong><br />DataStream &rarr; DataStream</td>
      <td>
        <p>
            广播每个元素到所有分区。

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">dataStream</span><span class="o">.</span><span class="na">broadcast</span><span class="o">();</span></code></pre></figure>

        </p>
      </td>
    </tr>
  </tbody>
</table>

  </div>

  <div data-lang="scala">

    <p><br /></p>

    <table class="table table-bordered">
  <thead>
    <tr>
      <th class="text-left" style="width: 20%">转换</th>
      <th class="text-center">描述</th>
    </tr>
  </thead>
  <tbody>
   <tr>
      <td><strong>自定义分区</strong><br />DataStream &rarr; DataStream</td>
      <td>
        <p>
            使用一个用户自定义的 Partitioner 对每一个元素选择目标 task。


<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">partitionCustom</span><span class="o">(</span><span class="n">partitioner</span><span class="o">,</span> <span class="s">&quot;someKey&quot;</span><span class="o">)</span>
<span class="n">dataStream</span><span class="o">.</span><span class="n">partitionCustom</span><span class="o">(</span><span class="n">partitioner</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span></code></pre></figure>

        </p>
      </td>
    </tr>
   <tr>
     <td><strong>随机分区</strong><br />DataStream &rarr; DataStream</td>
     <td>
       <p>
            以均匀分布的形式将元素随机地进行分区。


<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">shuffle</span><span class="o">()</span></code></pre></figure>

       </p>
     </td>
   </tr>
   <tr>
      <td><strong>Rebalancing (Round-robin partitioning)</strong><br />DataStream &rarr; DataStream</td>
      <td>
        <p>
            基于 round-robin 对元素进行分区，使得每个分区负责均衡。对于存在数据倾斜的性能优化是很有用的。

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">rebalance</span><span class="o">()</span></code></pre></figure>

        </p>
      </td>
    </tr>
    <tr>
      <td><strong>Rescaling</strong><br />DataStream &rarr; DataStream</td>
      <td>
        <p>
            以 round-robin 的形式将元素分区到下游操作的子集中。如果你想要将数据从一个源的每个并行实例中散发到一些 mappers 的子集中，用来分散负载，但是又不想要完全的 rebalance 介入（引入 `rebalance()`），这会非常有用。根据一些如TaskManager 的 slots 个数的配置，这将会只需要本地数据传输，而不是通过网络。
        </p>
        <p>
            上游操作所发送的元素被分区到下游操作的哪些子集，依赖于上游和下游操作的并发度。例如，如果上游操作的并发为 2 ，而下游操作的并发为 4 ，那么一个上游操作会分发元素给两个下游操作，同时另一个上游操作会分发给另两个下游操作。相反的，如果下游操作的并发为 2 ，而下游操作的并发为4，那么两个上游操作会分发数据给一个下游操作，同时另两个上游操作会分发数据给另一个下游操作。
        </p>
        <p>
            在上下游的并发度不是呈倍数关系的情况下，下游操作会有数量不同的来自上游操作的输入。
        </p>
        
            下图是对上述例子的一个可视化：
        

        <div style="text-align: center">
            <img src="/apis/streaming/fig/rescale.svg" alt="Checkpoint barriers in data streams" />
            </div>


        <p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">dataStream</span><span class="o">.</span><span class="na">rescale</span><span class="o">()</span></code></pre></figure>


        </p>
      </td>
    </tr>
   <tr>
      <td><strong>广播</strong><br />DataStream &rarr; DataStream</td>
      <td>
        <p>
            广播每个元素到所有分区。


<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">broadcast</span><span class="o">()</span></code></pre></figure>

        </p>
      </td>
    </tr>
  </tbody>
</table>

  </div>
</div>

<h3 id="section-2">任务链和资源组</h3>

<p>为了获得更好的性能，你可以链接（chaining）两个连续的转换，这意味着将它们置于同一个线程中。Flink 会尽可能地链接 operators （例如，两个 map 转换）。如果需要的话，该 API 提供了对链接（chaining）细粒度的控制。</p>

<p>如果你想要在整个任务中禁用 chaining ，使用 <code>StreamExecutionEnvironment.disableOperatorChaining()</code>。想了解更细粒度的控制，下面的函数是很有用的。注意这些函数只能被用在一个 DataStream 的转换之后，因为它们要指向之前的转换。例如，你可以 <code>someStream.map(...).startNewChain()</code>，但不能 <code>someStream.startNewChain()</code>。</p>

<p>在 Flink 中一个资源组就是一个 slot 。查阅 <a href="/setup/config.html#configuring-taskmanager-processing-slots">slots</a> 了解更多。如果需要的话，你可以手动地隔离 slot 。</p>

<div class="codetabs">
  <div data-lang="java">

    <table class="table table-bordered">
  <thead>
    <tr>
      <th class="text-left" style="width: 20%">转换</th>
      <th class="text-center">描述</th>
    </tr>
  </thead>
  <tbody>
   <tr>
      <td>Start new chain</td>
      <td>
        <p>从这个操作符开始一个新的链条（chain）。这两个 mapper 会被链接，而 filter 不会被与第一个 mapper 链上。
        

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">someStream</span><span class="o">.</span><span class="na">filter</span><span class="o">(...).</span><span class="na">map</span><span class="o">(...).</span><span class="na">startNewChain</span><span class="o">().</span><span class="na">map</span><span class="o">(...);</span></code></pre></figure>

        </p>
      </td>
    </tr>
   <tr>
      <td>Disable chaining</td>
      <td>
        <p>不要与这个 map operator 进行链接。

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">someStream</span><span class="o">.</span><span class="na">map</span><span class="o">(...).</span><span class="na">disableChaining</span><span class="o">();</span></code></pre></figure>

        </p>
      </td>
    </tr>
   <tr>
      <td>Start a new resource group</td>
      <td>
        <p>启动一个新的资源组，包含了这个 map 和之后的 operators。（译注：filter？）
        

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">someStream</span><span class="o">.</span><span class="na">filter</span><span class="o">(...).</span><span class="na">startNewResourceGroup</span><span class="o">();</span></code></pre></figure>

        </p>
      </td>
    </tr>
   <tr>
      <td>Isolate resources</td>
      <td>
        <p>将这个 operator 隔离在自己的 slot 中。

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">someStream</span><span class="o">.</span><span class="na">map</span><span class="o">(...).</span><span class="na">isolateResources</span><span class="o">();</span></code></pre></figure>

        </p>
      </td>
    </tr>
  </tbody>
</table>

  </div>

  <div data-lang="scala">

    <table class="table table-bordered">
  <thead>
    <tr>
      <th class="text-left" style="width: 20%">转换</th>
      <th class="text-center">描述</th>
    </tr>
  </thead>
  <tbody>
   <tr>
      <td>Start new chain</td>
      <td>
        <p>从这个操作符开始一个新的链条（chain）。这两个 mapper 会被链接，而 filter 不会被与第一个 mapper 链上。


<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">someStream</span><span class="o">.</span><span class="n">filter</span><span class="o">(...).</span><span class="n">map</span><span class="o">(...).</span><span class="n">startNewChain</span><span class="o">().</span><span class="n">map</span><span class="o">(...)</span></code></pre></figure>

        </p>
      </td>
    </tr>
   <tr>
      <td>Disable chaining</td>
      <td>
        <p>不要与这个 map operator 进行链接。


<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">someStream</span><span class="o">.</span><span class="n">map</span><span class="o">(...).</span><span class="n">disableChaining</span><span class="o">()</span></code></pre></figure>

        </p>
      </td>
    </tr>
   <tr>
      <td>Start a new resource group</td>
      <td>
        <p>启动一个新的资源组，包含了这个 map 和之后的 operators。（译注：filter？）


<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">someStream</span><span class="o">.</span><span class="n">filter</span><span class="o">(...).</span><span class="n">startNewResourceGroup</span><span class="o">()</span></code></pre></figure>

        </p>
      </td>
    </tr>
   <tr>
      <td>Isolate resources</td>
      <td>
        <p>将这个 operator 隔离在自己的 slot 中。


<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">someStream</span><span class="o">.</span><span class="n">map</span><span class="o">(...).</span><span class="n">isolateResources</span><span class="o">()</span></code></pre></figure>

        </p>
      </td>
    </tr>
  </tbody>
</table>

  </div>
</div>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h2 id="section-3">数据源</h2>

<div class="codetabs">
  <div data-lang="java">

    <p>源可以通过 <code>StreamExecutionEnvironment.addSource(sourceFunction)</code> 来创建。你可以使用 Flink 自带的数据源函数，也可以通过实现 <code>SourceFunction</code> 接口写一个自定义的非并行数据源，或者通过实现 <code>ParallelSourceFunction</code> 接口或者继承 <code>RichParallelSourceFunction</code> 来写一个并行的数据源。</p>

    <p>有一些预定义的流数据源，可以通过 <code>StreamExecutionEnvironment</code> 访问到。</p>

    <p>基于文件：</p>

    <ul>
      <li>
        <p><code>readTextFile(path)</code> / <code>TextInputFormat</code> - 读取文件行并将它们以 String 类型返回。</p>
      </li>
      <li>
        <p><code>readFile(path)</code> / 任何输入格式 - 以指定的输入格式读取文件。</p>
      </li>
      <li>
        <p><code>readFileStream</code> - 创建一个流，当文件有修改的时候，会将元素附加到流中。</p>
      </li>
    </ul>

    <p>基于 Socket：</p>

    <ul>
      <li><code>socketTextStream</code> - 从一个 socket 中读取数据，可以指定分隔符来切分元素。</li>
    </ul>

    <p>基于集合：</p>

    <ul>
      <li>
        <p><code>fromCollection(Collection)</code> - 从 Java java.util.Collection 集合中创建一个数据流。集合中的所有元素的类型必须一致。</p>
      </li>
      <li>
        <p><code>fromCollection(Iterator, Class)</code> - 从一个迭代器中创建一个数据流。Class 指定了迭代器返回的数据类型。</p>
      </li>
      <li>
        <p><code>fromElements(T ...)</code> - 从一个对象序列中创建一个数据流。所有的对象的类型必须一致。</p>
      </li>
      <li>
        <p><code>fromParallelCollection(SplittableIterator, Class)</code> - 从一个迭代器中创建一个并行数据流。Class 指定了迭代器返回的数据类型。</p>
      </li>
      <li>
        <p><code>generateSequence(from, to)</code> - 创建一个并行数据流，生成区间范围内的数字序列。</p>
      </li>
    </ul>

    <p>自定义：</p>

    <ul>
      <li><code>addSource</code> - 添加一个新的源函数。例如，从 Apache Kafka 读取的话你可以：<code>addSource(new FlinkKafkaConsumer08&lt;&gt;(...))</code>. 查阅 <a href="/apis/streaming/connectors/">连接器(connectors)</a> 了解更多。</li>
    </ul>

  </div>

  <div data-lang="scala">

    <p>源可以通过 <code>StreamExecutionEnvironment.addSource(sourceFunction)</code> 来创建。你可以使用 Flink 自带的数据源函数，也可以通过实现 <code>SourceFunction</code> 接口写一个自定义的非并行数据源，或者通过实现 <code>ParallelSourceFunction</code> 接口或者继承 <code>RichParallelSourceFunction</code> 来写一个并行的数据源。</p>

    <p>有一些预定义的流数据源，可以通过 <code>StreamExecutionEnvironment</code> 访问到。</p>

    <p>基于文件：</p>

    <ul>
      <li>
        <p><code>readTextFile(path)</code> / <code>TextInputFormat</code> - 读取文件行并将它们以 String 类型返回。</p>
      </li>
      <li>
        <p><code>readFile(path)</code> / 任何输入格式 - 以指定的输入格式读取文件。</p>
      </li>
      <li>
        <p><code>readFileStream</code> - 创建一个流，当文件有修改的时候，会将元素附加到流中。</p>
      </li>
    </ul>

    <p>基于 Socket：</p>

    <ul>
      <li><code>socketTextStream</code> - 从一个 socket 中读取数据，可以指定分隔符来切分元素。</li>
    </ul>

    <p>基于集合：</p>

    <ul>
      <li>
        <p><code>fromCollection(Seq)</code> - 从 Java java.util.Collection 集合中创建一个数据流。集合中的所有元素的类型必须一致。</p>
      </li>
      <li>
        <p><code>fromCollection(Iterator)</code> - 从一个迭代器中创建一个数据流。Class 指定了迭代器返回的数据类型。</p>
      </li>
      <li>
        <p><code>fromElements(elements: _*)</code> - 从一个对象序列中创建一个数据流。所有的对象的类型必须一致。</p>
      </li>
      <li>
        <p><code>fromParallelCollection(SplittableIterator)</code> - 从一个迭代器中创建一个并行数据流。Class 指定了迭代器返回的数据类型。</p>
      </li>
      <li>
        <p><code>generateSequence(from, to)</code> - 创建一个并行数据流，生成区间范围内的数字序列。</p>
      </li>
    </ul>

    <p>自定义：</p>

    <ul>
      <li><code>addSource</code> - 添加一个新的源函数。例如，从 Apache Kafka 读取的话你可以：<code>addSource(new FlinkKafkaConsumer08&lt;&gt;(...))</code>. 查阅 <a href="/apis/streaming/connectors/">连接器(connectors)</a> 了解更多。</li>
    </ul>

  </div>
</div>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h2 id="sinks">数据下沉（Sinks）</h2>

<div class="codetabs">
  <div data-lang="java">

    <p>数据下沉（sinks）消费了 DataStream 并将它们发往文件、socket、外部系统、或打印出来。Flink 拥有很多内建的输出格式，这些都被封装在了 DataStream 的操作背后：</p>

    <ul>
      <li>
        <p><code>writeAsText()</code> / <code>TextOuputFormat</code> - 以字符串的形式成行地输出元素。元素的字符串可以通过调用 <em>toString()</em> 获得。</p>
      </li>
      <li>
        <p><code>writeAsCsv(...)</code> / <code>CsvOutputFormat</code> - 将元组写入到 CSV 文件。 Writes tuples as comma-separated value files. 行和字段的分隔符是可以配置的。每个字段的值可以通过对象的 <em>toString()</em> 方法获得。</p>
      </li>
      <li>
        <p><code>print()</code> / <code>printToErr()</code>  - 打印每个元素的 <em>toString()</em> 值到标准输出流 / 标准错误流。可选的，可以提供一个前缀（msg）作为前置输出。这可以帮助区分不同次的调用 <em>print</em> 。如果并发度大于 1 ，task id 也会被前置到输出中。</p>
      </li>
      <li>
        <p><code>writeUsingOutputFormat()</code> / <code>FileOutputFormat</code> - 自定义文件输出的方法和基类。支持自定义的对象到字节的转换。</p>
      </li>
      <li>
        <p><code>writeToSocket</code> - 根据 <code>SerializationSchema</code> 将元素写入到 socket 中。</p>
      </li>
      <li>
        <p><code>addSink</code> - 调用自定义的 sink 方法。Flink 自带了很多连接器（connectors），用来连接其他系统（如 Apache Kafka），这些连接器都实现了 sink 方法。</p>
      </li>
    </ul>

  </div>
  <div data-lang="scala">

    <p>数据下沉（sinks）消费了 DataStream 并将它们发往文件、socket、外部系统、或打印出来。Flink 拥有很多内建的输出格式，这些都被封装在了 DataStream 的操作背后：</p>

    <ul>
      <li>
        <p><code>writeAsText()</code> / <code>TextOuputFormat</code> - 以字符串的形式成行地输出元素。元素的字符串可以通过调用 <em>toString()</em> 获得。</p>
      </li>
      <li>
        <p><code>writeAsCsv(...)</code> / <code>CsvOutputFormat</code> - 将元组写入到 CSV 文件。 Writes tuples as comma-separated value files. 行和字段的分隔符是可以配置的。每个字段的值可以通过对象的 <em>toString()</em> 方法获得。</p>
      </li>
      <li>
        <p><code>print()</code> / <code>printToErr()</code>  - 打印每个元素的 <em>toString()</em> 值到标准输出流 / 标准错误流。可选的，可以提供一个前缀（msg）作为前置输出。这可以帮助区分不同次的调用 <em>print</em> 。如果并发度大于 1 ，task id 也会被前置到输出中。</p>
      </li>
      <li>
        <p><code>writeUsingOutputFormat()</code> / <code>FileOutputFormat</code> - 自定义文件输出的方法和基类。支持自定义的对象到字节的转换。</p>
      </li>
      <li>
        <p><code>writeToSocket</code> - 根据 <code>SerializationSchema</code> 将元素写入到 socket 中。</p>
      </li>
      <li>
        <p><code>addSink</code> - 调用自定义的 sink 方法。Flink 自带了很多连接器（connectors），用来连接其他系统（如 Apache Kafka），这些连接器都实现了 sink 方法。</p>
      </li>
    </ul>

  </div>
</div>

<p>注意 <code>DataStream</code> 的 <code>write*()</code> 方法主要是用来 debug 的。它们不会参与 Flink 的 checkpoint 机制，这意味着这些函数一般只有最少一次（at-lease-once）语义。数据刷到目标系统的动作依赖于 OutputFormat 的实现。这也就是说不是所有发送给 OutputFormat 的元素会立即在目标系统上可见。另外，在失败的情况下，这些记录可能会丢失。</p>

<p>为了可靠性，可以用 <code>flink-connector-filesystem</code> 实现流到文件系统的恰好一次（exactly-once）。同样的，可以通过 <code>.addSink(...)</code> 方法自己实现 SinkFunction，这也能参与 Flink 的 checkpoint 机制，达到 exactly-once 语义。</p>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h2 id="iterations">迭代（Iterations）</h2>

<div class="codetabs">
  <div data-lang="java">

    <p>迭代的流程序实现了一个分步的函数并嵌入到了 <code>IterativeStream</code> 中。因为一个 DataStream 程序可能永远不会结束的，所以迭代次数没有上限。你需要指出流的哪部分是要反馈到迭代中的，哪部分是要继续往下游发送的，这可以用 <code>split</code> 或 <code>filter</code> 转换来实现。这里，我们给出一个使用 filters 的样例。首先，我们定义了一个 <code>IterativeStream</code>。</p>

    <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">IterativeStream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">iteration</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">iterate</span><span class="o">();</span></code></pre></figure>

    <p>然后，我们使用一系列的转换来说明了迭代中被执行的逻辑（这里就是一个简单 <code>map</code> 转换）。</p>

    <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">iterationBody</span> <span class="o">=</span> <span class="n">iteration</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="cm">/* this is executed many times */</span><span class="o">);</span></code></pre></figure>

    <p>要关闭一个迭代并定义迭代的尾部，请调用 <code>IterativeStream</code> 的 <code>closeWith(feedbackStream)</code> 方法。传给 <code>closeWith</code> 方法的 DataStream 会被反馈给迭代的头部。一种常见的形式就是使用一个 filter 来分离流中需要被反馈的部分和需要被继续发往下游的部分。在 filter 中可以定义“结束”逻辑，来决定了一个元素是被发往下游还是被反馈的。</p>

    <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">iteration</span><span class="o">.</span><span class="na">closeWith</span><span class="o">(</span><span class="n">iterationBody</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="cm">/* one part of the stream */</span><span class="o">));</span>
<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">output</span> <span class="o">=</span> <span class="n">iterationBody</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="cm">/* some other part of the stream */</span><span class="o">);</span></code></pre></figure>

    <p>默认情况下，反馈流的分区将被自动设定为与迭代头部的输入相同的分区。用户可以在 <code>closeWith</code> 方法中设置一个可选的布尔 flag 来覆盖这种默认行为。</p>

    <p>例如，下面这段程序就是对一串数字不断地做减 1 操作，知道它们都为 0 了为止。</p>

    <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">someIntegers</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">generateSequence</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1000</span><span class="o">);</span>

<span class="n">IterativeStream</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">iteration</span> <span class="o">=</span> <span class="n">someIntegers</span><span class="o">.</span><span class="na">iterate</span><span class="o">();</span>

<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">minusOne</span> <span class="o">=</span> <span class="n">iteration</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="k">new</span> <span class="n">MapFunction</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;()</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Long</span> <span class="nf">map</span><span class="o">(</span><span class="n">Long</span> <span class="n">value</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">value</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">;</span>
  <span class="o">}</span>
<span class="o">});</span>

<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">stillGreaterThanZero</span> <span class="o">=</span> <span class="n">minusOne</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="k">new</span> <span class="n">FilterFunction</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;()</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">filter</span><span class="o">(</span><span class="n">Long</span> <span class="n">value</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">value</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">});</span>

<span class="n">iteration</span><span class="o">.</span><span class="na">closeWith</span><span class="o">(</span><span class="n">stillGreaterThanZero</span><span class="o">);</span>

<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">lessThanZero</span> <span class="o">=</span> <span class="n">minusOne</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="k">new</span> <span class="n">FilterFunction</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;()</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">filter</span><span class="o">(</span><span class="n">Long</span> <span class="n">value</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">});</span></code></pre></figure>

  </div>
  <div data-lang="scala">

    <p>迭代的流程序实现了一个分步的函数并嵌入到了 <code>IterativeStream</code> 中。因为一个 DataStream 程序可能永远不会结束的，所以迭代次数没有上限。你需要指出流的哪部分是要反馈到迭代中的，哪部分是要继续往下游发送的，这可以用 <code>split</code> 或 <code>filter</code> 转换来实现。这里，我们给出一个迭代样例，其中主体部分（不断重复计算的部分）是一个简单的 map 转换，而每个元素到底是被反馈还是被发往下游主要是使用 filter 来区分的。</p>

    <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">iteratedStream</span> <span class="k">=</span> <span class="n">someDataStream</span><span class="o">.</span><span class="n">iterate</span><span class="o">(</span>
  <span class="n">iteration</span> <span class="k">=&gt;</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">iterationBody</span> <span class="k">=</span> <span class="n">iteration</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="cm">/* this is executed many times */</span><span class="o">)</span>
    <span class="o">(</span><span class="n">tail</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="cm">/* one part of the stream */</span><span class="o">),</span> <span class="n">tail</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="cm">/* some other part of the stream */</span><span class="o">))</span>
<span class="o">})</span></code></pre></figure>

    <p>默认情况下，反馈流的分区将被自动设定为与迭代头部的输入相同的分区。用户可以在 closeWith 方法中设置一个可选的布尔 flag 来覆盖这种默认行为。</p>

    <p>例如，下面这段程序就是对一串数字不断地做减 1 操作，知道它们都为 0 了为止。</p>

    <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">someIntegers</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">generateSequence</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1000</span><span class="o">)</span>

<span class="k">val</span> <span class="n">iteratedStream</span> <span class="k">=</span> <span class="n">someIntegers</span><span class="o">.</span><span class="n">iterate</span><span class="o">(</span>
  <span class="n">iteration</span> <span class="k">=&gt;</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">minusOne</span> <span class="k">=</span> <span class="n">iteration</span><span class="o">.</span><span class="n">map</span><span class="o">(</span> <span class="n">v</span> <span class="k">=&gt;</span> <span class="n">v</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">stillGreaterThanZero</span> <span class="k">=</span> <span class="n">minusOne</span><span class="o">.</span><span class="n">filter</span> <span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">lessThanZero</span> <span class="k">=</span> <span class="n">minusOne</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">_</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span>
    <span class="o">(</span><span class="n">stillGreaterThanZero</span><span class="o">,</span> <span class="n">lessThanZero</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">)</span></code></pre></figure>

  </div>
</div>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<p><a id="execution-parameters"></a></p>

<h2 id="section-4">执行参数</h2>

<p><code>StreamExecutionEnvironment</code> 包含了 <code>ExecutionConfig</code>，<code>ExecutionConfig</code> 用来设置任务运行时的具体配置值。</p>

<p>请参考 <a href="/apis/common/index.html#execution-configuration">execution configuration</a> 了解更多参数的说明。下面这些参数是 DataStream API 特有的：</p>

<ul>
  <li>
    <p><code>enableTimestamps()</code> / <strong><code>disableTimestamps()</code></strong>: 启用的话，从源发出的每一条消息（event）都会附加上一个时间戳。<code>areTimestampsEnabled()</code> 返回了当前是否启用的值。</p>
  </li>
  <li>
    <p><code>setAutoWatermarkInterval(long milliseconds)</code>: 设置自动水位排放的间隔时间。你可以通过 <code>long getAutoWatermarkInterval()</code> 获得当前值。</p>
  </li>
</ul>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h3 id="section-5">容错</h3>

<p><a href="fault_tolerance.html">容错章节</a> 描述了启用和配置 Flink checkpoint 机制的选项和配置项。</p>

<h3 id="section-6">延迟控制</h3>

<p>默认情况下，数据并不是一个接着一个在网络上传输的（这会导致不必要的网络流量），而是被缓冲的（buffered）。缓冲（实际上是机器之间的传输） 的大小可以在 Flink 配置文件中设置。虽然这种方法有利于优化吞吐量，但当输入的数据流不够快时，它可能会导致延迟问题时。要控制吞吐量和延迟，你可以在 <code>StreamExecutionEnvironment</code> 上使用<code>env.setBufferTimeout(timeoutMillis)</code>（或者单独的 operator 上）设置等待缓冲区被填满的最长等待时间。超过了这个时间，即时缓冲区还没有满也会被自动发送出去。默认的超时时间是 100 ms。</p>

<p>用法:</p>

<div class="codetabs">
  <div data-lang="java">

    <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">LocalStreamEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">StreamExecutionEnvironment</span><span class="o">.</span><span class="na">createLocalEnvironment</span><span class="o">();</span>
<span class="n">env</span><span class="o">.</span><span class="na">setBufferTimeout</span><span class="o">(</span><span class="n">timeoutMillis</span><span class="o">);</span>

<span class="n">env</span><span class="o">.</span><span class="na">genereateSequence</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">10</span><span class="o">).</span><span class="na">map</span><span class="o">(</span><span class="k">new</span> <span class="nf">MyMapper</span><span class="o">()).</span><span class="na">setBufferTimeout</span><span class="o">(</span><span class="n">timeoutMillis</span><span class="o">);</span></code></pre></figure>

  </div>
  <div data-lang="scala">

    <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="nc">LocalStreamEnvironment</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">StreamExecutionEnvironment</span><span class="o">.</span><span class="n">createLocalEnvironment</span>
<span class="n">env</span><span class="o">.</span><span class="n">setBufferTimeout</span><span class="o">(</span><span class="n">timeoutMillis</span><span class="o">)</span>

<span class="n">env</span><span class="o">.</span><span class="n">genereateSequence</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">10</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">myMap</span><span class="o">).</span><span class="n">setBufferTimeout</span><span class="o">(</span><span class="n">timeoutMillis</span><span class="o">)</span></code></pre></figure>

  </div>
</div>

<p>为了最大化吞吐量，可以设置 <code>setBufferTimeout(-1)</code>，这会移除超时等待时间而缓冲区只有被填满后才会被发送出去。为了最小化延时，可以设置一个接近 0 的超时时间（如 5 或 10 毫秒）。建议避免缓冲超时时间为 0 ，因为这会降低服务性能。</p>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h2 id="section-7">调试</h2>

<p>先确保实现的算法按照预期正常工作了，再将这个 streaming 程序跑到分布式集群上，是一个好想法。因此，实现数据分析程序通常是一个渐进的过程：检查结果、调试和改进。</p>

<p>Flink 提供了许多特性来极大地简化了数据分析程序的开发过程。比如支持了在 IDE 中进行本地调试，测试数据注入，和结果数据的收集。本节主要就如何简化开发 Flink 程序提供一些提示。</p>

<h3 id="section-8">本地执行环境</h3>

<p><code>LocalStreamEnvironment</code> 会在同一个 JVM 进程中启动一个 Flink 引擎。如果你从 IDE 中启动了<code>LocalStreamEnvironment</code>，你可以在你的代码中设置断点，然后轻松地调试你的程序。</p>

<p>一个 LocalEnvironment 可以像下面这样被创建和使用；</p>

<div class="codetabs">
  <div data-lang="java">

    <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">StreamExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">StreamExecutionEnvironment</span><span class="o">.</span><span class="na">createLocalEnvironment</span><span class="o">();</span>

<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">addSource</span><span class="o">(</span><span class="cm">/* some source */</span><span class="o">);</span>
<span class="c1">// build your program</span>

<span class="n">env</span><span class="o">.</span><span class="na">execute</span><span class="o">();</span></code></pre></figure>

  </div>
  <div data-lang="scala">

    <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">StreamExecutionEnvironment</span><span class="o">.</span><span class="n">createLocalEnvironment</span><span class="o">()</span>

<span class="k">val</span> <span class="n">lines</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">addSource</span><span class="o">(</span><span class="cm">/* some source */</span><span class="o">)</span>
<span class="c1">// build your program</span>

<span class="n">env</span><span class="o">.</span><span class="n">execute</span><span class="o">()</span></code></pre></figure>

  </div>
</div>

<h3 id="section-9">集合数据源</h3>

<p>Flink 提供了基于 Java 集合实现的特殊数据源，用来简化测试。一旦一个程序测试通过了，数据源和 sinks 可以被方便地替换成从外部系统读写的数据源和 sinks。</p>

<p>集合数据源可以以如下的方式使用：</p>

<div class="codetabs">
  <div data-lang="java">

    <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">StreamExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">StreamExecutionEnvironment</span><span class="o">.</span><span class="na">createLocalEnvironment</span><span class="o">();</span>

<span class="c1">// Create a DataStream from a list of elements</span>
<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">myInts</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">fromElements</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>

<span class="c1">// Create a DataStream from any Java collection</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">myTuples</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">fromCollection</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>

<span class="c1">// Create a DataStream from an Iterator</span>
<span class="n">Iterator</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">longIt</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">myLongs</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">fromCollection</span><span class="o">(</span><span class="n">longIt</span><span class="o">,</span> <span class="n">Long</span><span class="o">.</span><span class="na">class</span><span class="o">);</span></code></pre></figure>

  </div>
  <div data-lang="scala">

    <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">StreamExecutionEnvironment</span><span class="o">.</span><span class="n">createLocalEnvironment</span><span class="o">()</span>

<span class="c1">// Create a DataStream from a list of elements</span>
<span class="k">val</span> <span class="n">myInts</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">fromElements</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>

<span class="c1">// Create a DataStream from any Collection</span>
<span class="k">val</span> <span class="n">data</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">val</span> <span class="n">myTuples</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">fromCollection</span><span class="o">(</span><span class="n">data</span><span class="o">)</span>

<span class="c1">// Create a DataStream from an Iterator</span>
<span class="k">val</span> <span class="n">longIt</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">val</span> <span class="n">myLongs</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">fromCollection</span><span class="o">(</span><span class="n">longIt</span><span class="o">)</span></code></pre></figure>

  </div>
</div>

<p><strong>注意：</strong> 现在，集合数据源需要数据类型和迭代器都实现 <code>Serializable</code>。此外，集合数据源不能被并行执行（parallelism = 1）。</p>

<h3 id="iterator-data-sink">数据接收迭代器（Iterator Data Sink）</h3>

<p>Flink 为了测试和调试的目的还提供了一个 sink 来收集 DataStream 的结果。可以像下面这样使用：</p>

<div class="codetabs">
  <div data-lang="java">

    <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">org.apache.flink.contrib.streaming.DataStreamUtils</span>

<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">myResult</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">Iterator</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">myOutput</span> <span class="o">=</span> <span class="n">DataStreamUtils</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">myResult</span><span class="o">)</span></code></pre></figure>

  </div>
  <div data-lang="scala">

    <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.flink.contrib.streaming.DataStreamUtils</span>
<span class="k">import</span> <span class="nn">scala.collection.JavaConverters.asScalaIteratorConverter</span>

<span class="k">val</span> <span class="n">myResult</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">val</span> <span class="n">myOutput</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">DataStreamUtils</span><span class="o">.</span><span class="n">collect</span><span class="o">(</span><span class="n">myResult</span><span class="o">.</span><span class="n">getJavaStream</span><span class="o">).</span><span class="n">asScala</span></code></pre></figure>

  </div>
</div>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

      <div class="footer">
      发现错误？想参与编辑？
      <a href="https://github.com/wuchong/flink-china-doc/edit/master/apis/streaming/index.md" target="_blank">
        在 Github 上编辑此页！
      </a>
    </div>
    </div>
  </div>

  
</div>

    </div><!-- /.container -->

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="//cdn.bootcss.com/jquery/1.11.2/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="//cdn.bootcss.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
    <script src="/page/js/codetabs.js"></script>

    <!-- Google Analytics -->
    <!-- script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-52545728-1', 'auto');
      ga('send', 'pageview');
    </script -->

    <!-- Baidu Analytics -->
    <script>
      var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?835985ad7943d8c24bc3c1f155b7d4a2";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();
    </script>


    <!-- Disqus -->
    
  </body>
</html>
